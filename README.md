# FastAPI Users API

A simple CRUD REST API for managing users, built with **FastAPI** and **MariaDB**, containerized with **Docker** and deployed to **AWS EC2**.

This project was created as a learning exercise to practice:

- building a REST API with FastAPI
- using SQLAlchemy and Pydantic with a relational database
- containerizing services with Docker and docker-compose
- deploying a backend service to an EC2 instance on AWS

---

## Features

- `GET /hello` – simple health-check endpoint (`{"msg": "Hello DevOps"}`)
- `GET /users` – list all users
- `GET /users/{user_id}` – get a single user by ID
- `POST /users` – create a new user (name + unique email)
- `PUT /users/{user_id}` – update an existing user
- `DELETE /users/{user_id}` – delete a user

All endpoints return JSON responses. API documentation is automatically generated by FastAPI and is available at:

- Swagger UI: `/docs`
- ReDoc: `/redoc`

---

## Tech Stack

- **Language:** Python 3.11
- **Web framework:** FastAPI
- **Database:** MariaDB 11
- **ORM / DB layer:** SQLAlchemy
- **Data validation:** Pydantic
- **Server:** Uvicorn
- **Containerization:** Docker, docker-compose
- **Cloud:** AWS EC2 (Ubuntu)

---

## Project Structure

```text
app/
├── __init__.py
├── main.py        # FastAPI application, routes/endpoints
├── models.py      # SQLAlchemy models (User)
├── schemas.py     # Pydantic schemas (UserCreate, UserRead)
└── database.py    # DB engine, SessionLocal, Base

docker-compose.yml # API + MariaDB services
Dockerfile         # Build instructions for FastAPI API image
requirements.txt   # Python dependencies
.env.example       # Example env vars (no secrets)

docs/
└── screenshots/   # API, Swagger UI, AWS EC2, docker ps, ...
```
---

## Getting Started

### Requirements
- Docker installed  
- docker-compose available  
- Git (to clone the repository)

---

### 1. Clone the Repository

`git clone https://github.com/gavura1/Fastapi-users-api.git`
`cd Fastapi-users-api`

---

### 2. Environment Variables

Create `.env` based on `.env.example`:

`cp .env.example .env`

`DATABASE_URL="mysql+pymysql://user:password@localhost:3307/users_db"`

---

### 3. Running with Docker Compose

`docker-compose up --build`

This will:

- start the MariaDB container
- start the FastAPI application on Uvicorn
- expose API on port **8000**

API URLs:

- http://localhost:8000  
- http://localhost:8000/hello  
- http://localhost:8000/users  
- http://localhost:8000/docs 

Run in background:

`docker-compose up -d --build`

Stop containers:

`docker-compose down`

---

### 4. Deployment on AWS EC2

The project was deployed on an AWS EC2 **t2.micro** instance:

- Ubuntu 22.04
- Docker and docker-compose installed
- Repository cloned on the server
- Application started with:
`docker-compose up -d --build`

The EC2 Security Group allows inbound traffic on:

- 8000/tcp (FastAPI application port)
- 22/tcp (SSH access)

---

## Screenshots

![Swagger UI](docs/screenshots/swagger-ui.png)
![Create User](docs/screenshots/create-user.png)
![Create User Response](docs/screenshots/create-user-response.png)
![List Users](docs/screenshots/list-users.png)
![List Users Response](docs/screenshots/list-users-response.png)
![Delete User](docs/screenshots/delete-user.png)
![Docker PS](docs/screenshots/docker-ps.png)
![EC2 Details](docs/screenshots/aws-ec2-details.png)
![EC2 Overview](docs/screenshots/aws-ec2-overview.png)

---

## What I Learned

This was my first full project combining FastAPI, Docker, databases, and cloud deployment.  
Even though I used AI assistance during development, the project helped me understand the full lifecycle of building and deploying a backend service.  
Here are the main things I learned:

### FastAPI and Python Backend Development
- How a basic CRUD REST API is structured.
- How routing, request handling, and JSON responses work.
- How to use Pydantic models for validation and SQLAlchemy models for database operations.
- Why separating `models.py`, `schemas.py`, `database.py`, and `main.py` improves maintainability.

### Working With Databases
- How to define database models using SQLAlchemy.
- How to run a MariaDB instance in Docker instead of installing it locally.
- How connection strings (like `DATABASE_URL`) work and why environment variables are important.

### Docker & Containerization
- Why Docker is used in modern development (portability, reproducibility, speed).
- How to write a Dockerfile for a Python application.
- How to run multi-service environments using `docker-compose`.
- How containers communicate inside a virtual network (`db` → `api`).

### Cloud Deployment (AWS EC2)
- Why EC2 is used as a remote virtual machine for hosting applications.
- How to connect to EC2, install Docker, and deploy the app.
- How security groups and firewall rules affect accessibility.
- How deploying a containerized app differs from running it locally.

### Git & Version Control
- How to structure a project for GitHub.
- How `.gitignore` and `.env.example` are used in professional projects.
- How to push changes, commit meaningful messages, and maintain a clean repository.

### General DevOps Thinking
- Understanding the difference between local, container, and cloud environments.
- Why reproducibility, automation, and consistency matter in backend & DevOps workflows.
- How infrastructure and application engineering connect together.

---

## Challenges & How I Solved Them

Even though the project is relatively small, I encountered multiple challenges.  
Because I am still learning, I often used ChatGPT to help me understand errors or concepts.  
However, I always verified the solutions and tried to understand why they worked.

Here are the main challenges:

### 1. Understanding Project Structure
At the beginning, I didn’t know how FastAPI projects should be organized.  
I learned that separating routes, models, schemas, and database logic is important for scalability and clean code.

### 2. Database Integration
Errors related to MariaDB connection strings, port mapping, or SQLAlchemy sessions were common.  
Through debugging and AI guidance, I learned:
- how SQLAlchemy sessions work,  
- how migrations and table creation work,  
- why incorrect credentials or container startup timing cause failures.

### 3. Docker Networking Issues
I struggled with container-to-container communication (`api` → `db`).  
I learned that:
- containers inside docker-compose share the same internal network,
- the database hostname should be `db` not `localhost`,
- startup delays sometimes require waiting (`sleep 15` trick).

### 4. Deployment Confusion (EC2)
I had no idea how to run the project on a remote machine.  
During deployment I learned:
- how to SSH into EC2,
- how to install Docker on Ubuntu,
- how to expose ports properly,
- how security groups control which ports are open to the public.

### 5. GitHub Workflow
This was my first project where I had to manage:
- README documentation,
- project structure,
- ignoring sensitive files,
- keeping the repo clean.

This taught me practical version control skills that I will use in future projects.

---

## Future Improvements (DevOps Roadmap)

To continue developing this project and practice more DevOps skills, I plan to add:

### 1. CI/CD Pipeline (GitHub Actions)
- automate testing
- build Docker images automatically
- push images to Docker Hub or Amazon ECR
- deploy new versions to EC2 on every commit

### 2. Infrastructure as Code
Use Terraform or AWS CloudFormation to:
- create EC2 instances
- set up networking & security groups
- automate AWS provisioning

### 3. Reverse Proxy & HTTPS
Add an Nginx container to:
- provide HTTPS using Let's Encrypt
- route traffic to the FastAPI backend
- improve security and production readiness

### 4. Logging & Monitoring
Integrate:
- Prometheus + Grafana for metrics  
- Loki or ELK stack for logs  
- health checks and alerts  

### 5. Kubernetes (Long-term Goal)
Deploy the application on a Kubernetes cluster using:
- deployments
- services
- ingress
- ConfigMaps / Secrets

---

## License

This project is for educational purposes.
